=head1 Defending E-mail Users from Spam and Viruses

=head2 Introduction

=head2 Understanding the Postfix C<content_filter> Mechanism

The Postfix mail transfer agent (MTA) provides C<content_filter>, a
flexible mechanism designed to allow the integration of arbitrary mail
filters through a well-defined interface.  Postfix passes the message
into the content filter at the queuing stage, which in the diagrams in
the Postfix documentation is labelled I<qmgr>, which is the name of the
internal process that maintains queues for incoming and outgoing messages.
The drawback of the placement of filtering at the point in the system is
that the message has already been accepted into the system from the remote
server, so instead of directly rejecting the message when it's initially
delivered though an SMTP reject status code (5XX), the message is bounced.

In recent Postfix snapshots there is support for filtering at SMTP level;
however, it must be handled with care because SMTP has relatively short
time-outs, which may not tolerate the extra time required to perform
content checking.  Obviously, there will be scalability issues with this
configuration.  Since it is a still experimental and somewhat dangerous,
this article will not explore, concentrating instead on the more mature
C<content_filter> mechanism.

The simplest of the interfaces is a simple UNIX pipe, where Postfix writes
to the filter's standard input and and checks the filters return values
for pre-defined status codes.  Mail is injected back into Postfix using
the C<sendmail> command, which is the Postfix replacement for the same
command Sendmail uses.  The example in the C<FILTER_README> file that ships
with Postfix uses C<cat> and acts as a simple pass-through filter, which
does nothing.  You could, for example, write a filter to pass it though
C<tac> to reverse all the lines of the message (not that you'd want to).

The pipe mechanism, however, is not the best interface for complex
mail filtering.  The best interface for our purposed uses the filter
as an SMTP proxy; this provides a well-defined interface between
Postfix and the filter and it allows a persistent scanning daemon,
which can save considerable overhead required for repeated start-up
and easily permit the filtering proxy to implement reliable delivery.
Also, because it uses SMTP, it operates over TCP/IP, so the content
filter can be located on a separate host than the actual Postfix
service that receives the mail.

The C<content_filter> requires Postfix to connect to the proxy as an
SMTP client, which handles the message and then connects back into
a special SMTP server listening on a non-default port which handles
the final routing and delivery of the message.  As mentioned before,
Postfix sends the message to the content filter at the queuing
stage; this will be called the "sending process"; the message is
re-injected into the Postfix system in the C<smtpd> stage, which
will be called the "receiving process."

=head2 Scanning with C<amavisd-new>

C<amavisd-new> operates as an SMTP proxy, designed to hook in to
the C<content_filter> mechanism of Postfix.  (C<amavisd-new> also
supports Sendmail through its Milter interface and in a dual-server
configuration and Exim using it as an SMTP proxy.)  C<amavisd-new>
is written, maintained, and supported by Mark Martinec of the
Jozef Stefan Institue in Slovenija and is aided by an active
user community.  It began as a fork from C<amavisd>, a daemonized
version of the AMaViS scanner, which was one of the first open
source mail virus scanners.  The modern C<amavisd-new> scarcely
resemebles its predecessor and improves upon it considerably,
while a difference of philosophies has prevented C<amavisd-new>
from being merged back into C<amavisd> or simply taking over as the
official scanning engine of the AMaViS project.  That should not
sound like a euphemism for saying that either Mark or the developers
of the original AMaViS have overbearing personalities; Mark himself
is helpful and personable on the amavis-users mailing list, and the
original AMaViS folks have been quite tolerant of the C<amavisd-new>
traffic on their list, which these days accounts for at least half.

C<amavisd-new> is written in Perl, and takes advantage of a number
of well-written Perl modules, such as the Net::Server module,
which it uses to implement a forked parent/child environment,
much like the traditional Apache.  Since it is written in Perl,
it is able to directly use the Mail::SpamAssassin modules, which
implement the core scanning engine of SpamAssassin.

Mark strives make C<amavisd-new> adhere to standards and as a result
is not widely regarded as "broken" and many systems administrators
and developers hold it in high regard.  It is also fairly fast,
although as a Perl application it can use a considerable amount
of memory, so it is best limited to only a few child processes.
It is very flexible, but can be intimidating to configure.

Since C<amavisd-new> operates as an SMTP proxy within Postfix, it
is able to reliably deliver messages because it never has to store
the messages itself; it connects to the Postfix receiving process
as soon as the sending process connects to it, and does not send
an acceptance response to the sending process until the receiving
process has also accepted the message.  Should the receiving process
fail in some way, C<amavisd-new> will return a status code indicating
such, and Postfix will maintain the message in its queue until the
problem is rectified.

Because C<amavisd-new> runs as a daemon, it saves considerable
overhead over a design which runs as a normal pipe-filter.
In particular, the initialization of SpamAssassin can be quite
slow, which is why SpamAssassin itself ships with 'spamd', which
provides a persistent daemon to scan mail to avoid this overhead,
with a command-line client, 'spamc', with which other mail
filters like Procmail my communicate.  Since C<amavisd-new> uses
Mail::SpamAssassin directly, it does not need 'spamd' to be running.

=head2 Other Components

=head3 Sophos SAVI and Sophie

Sophos Anti-Virus may be the best kept secret in the anti-virus industry.
Sophos produces a very high quality scanning engine and provides very
good support.  Sophos caters to the enterprise, so their products
are built for a diversity of platforms, including OpenVMS.  Since they
cater to the enterprise, their products will not be seen in boxes on the
shelves of retail stores, which is part of the reason they are able to
maintain their high quality support.  (NB: I am a Sophos reseller, so my
opinions are biased.)  Sophos introduced a product called MailMonitor
a couple of years ago which also acts as a virus-scanning SMTP proxy,
and have recently acquired ActiveState, chiefly for their PureMessage
spam-filtering product (which also uses SpamAssassin).  I have been fairly
happy with C<amavisd-new> in these roles and have not widely deployed
MailMonitor and PureMessage.

Most of Sophos' products ship with 'sweep', a command-line scanner, but
the the command-line client is mostly a wrapper around SAVI, their scanning
engine library.  SAVI can also be licensed on its own in block of 50 users
and for customers who only want e-mail filtering or already have another
anti-virus product, this what I usually use.  Sophos provides the C headers
to SAVI to developers, and Vanja Hrustic used them to implement Sophie.
Sophie is a daemonized scanner which external processes communicate with
through a UNIX domain socket.  Because loading the virus definitions
and initializing the scanning engine requires considerable overhead in
program initialization, it is better to have a daemon, especially when
using 'sweep' would require many invocations.

=head3 SpamAssassin

SpamAssassin itself probably needs no introduction.  It is widely regarded
as the best open source spam-filtering engine available (and is probably
better than most proprietary offerings also).  It includes a wide range of
heuristic patterns and scores which are applied to messages, connections
to external sources, such as DNSRBLs, Razor2 and DCC.  Later versions
also implement Bayesian classification, which greatly improves detection
quality.

SpamAssassin operates by applying a number of heuristic tests to messages,
and then scoring the message.  Since a number of tests are used, more
factors are taken into consideration than a simple filter which just
matches keywords.  This provides a more accurate test; consider, for
example, if you were to reject anything as spam containing the word
"viagra", you would avoid a lot of viagra-related spam, but you would
also miss the joke forwarded to you by your buddy or the polite request
from your wife.  Configurable thresholds allow an administrator or user to
decide how aggressive to be when deciding whether or not a message is spam.

The more tests you can add to SpamAssassin, the higher the scores will
be for spam, so the higher you can you set the thresholds and the more
accurate your filtering will be.  Razor2, DCC, and Pyzor are external tests
which you will probably want to install.  All three work by computing
checksums of messages which have been recognized as spam and comparing
those to databases.  DCC uses a fuzzy checksum to catch more spam,
especially messages where spammers have added random characters to parts of
the message in an attempt to fool the other systems.  If you are able, you
should also register and send checksums of spam not caught by these back
to network; they operate as volunteer efforts, so your contributions help.
I have not actually used Pyzor, because it requires a later version of
Python than is installed on most of my servers, but the SpamAssassin
C<INSTALL> document recommends it, so it is probably safe to use.

SpamAssassin will also use DNS real-time black-hole lists (DNSRBLs) and
right-hand-side black-hole list (RHSBLs).  It assigns different scores
based on the reputation or focus of the RBL, and as a result is safer
than using the lists directly; for example, instead of simply blocking
all messages originating at from a dial-up address, the RBL simply adds
to the score, so if the message is otherwise not spam-like, it will be
allowed through.  (I have actually seen some desperate ISPs block mail
entirely from all addresses from particular national IPSs, which is a
very bad practice, since it alienates sizable portions of the Internet.)
SpamAssassin is also able to apply the RBL tests to all hosts through which
the message has passed, which is more effective than only applying it to
the SMTP peer, as an MTA usually does.  A limited number of conservative
RBLs on the SMTP server itself are still not a bad idea, however.

Among the newest and most exciting features is the Bayesian classification
and auto-learning, which allow it to learn spam and non-spam based on
scores of messages it sees.  Bayesian classification is sophisticated
technique to determine the likelihood of a message being spam or not,
based on identifying tokens (words, etc.) as either being most frequently
in spam or "ham" (non-spam).  It's a good deal more flexible than the
basic keyword and phrase matching that SpamAssassin does without it;
as a result it has to learn which tokens are spam tokens and which are
ham tokens, so it must be trained, usually be feeding it messages and
indicated which it is.  Since SpamAssassin still has a number of other
tests it performs, it can also automatically teach the Bayesian classifier
based on the message's score, so it continuously adapts its idea of what
is spam or ham based on the messages it receives.

=head2 Putting It All Together

First, make sure you've got Postfix working as it should.  Always try
to proceed in small, incremental steps.  Next, configure amavisd-new.
The configuration file defaults to C</etc/amavisd.conf>, but I prefer
to relocate mine to /etc/amavis/amavisd.conf by giving it the C<-c>
option at start-up.  The C<amavisd.conf> file itself is very heavily
commented, and I recommend that you read through the whole thing.  Here are a
few changes from the defaults that should get you started:

This one is obvious; you want to set your local domain here:
$mydomain = 'example.com'; 

I prefer to run mine as user/group 'amavis/amavis', created with
home directory /var/amavis:

$daemon_user  = 'vscan';
$daemon_group = 'sweep';

I like to make the directory C<amavisd-new> does most of its work
in a tmpfs file system, but you want certain things (like the
SpamAssassin Bayesian database) to be persistently stored, so the temporary
directory should be a subdirectory of the home directory:

$TMPBASE = $MYHOME/tmp

The C<FILTER_README> from Postfix and the C<README.postfix> from
C<amavisd-new> differ on which ports to use; the former uses 10025
and 10026, while the latter uses 10024 and 10025.  It doesn't matter
which you choose, as long as you use the pair consistently.  If you want to
use change to the (10025,10026) pair, use:

$inet_socket_port = 10025;
$forward_method = 'smtp:127.0.0.1:10026';
$notify_method = $forward_method;

=head2 Understanding Logging

=head2 Debugging

=head2 Conclusion

=cut

vim: ft=pod
